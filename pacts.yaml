# basic information for generating and executing this definition
SenzaInfo:
  StackName: "pacts"
  Parameters:
  - ImgTag:
      Description: "Docker image tag to deploy"
  - InstanceType:
      Description: "Instance type to use"
      Description: "Instance type to use"
  - AWSMintRegion:
      Description: "AWS region for the mint bucket, could be different from the instance region"
  - ScalyrKey:
      Description: "Scalyr logs access key"
  - Stage:
      Description: "Environment type"
      AllowedValues: ["live", "test"]
  - ApplicationId:
      Description: "Application id"
      AllowedValues: ["pacts", "pacts-staging"]

# a list of senza components to apply to the definition
SenzaComponents:

  # this basic configuration is required for the other components
  - Configuration:
      Type: Senza::StupsAutoConfiguration # auto-detect network setup

  # will create a launch configuration and auto scaling group with scaling triggers
  - AppServer:
      Type: Senza::TaupageAutoScalingGroup
      # General Purpose T2: t2.nano, t2.micro, t2.small, t2.medium, t2.large
      # Note that if an instance type is not available in one region you will get
      # ERROR: AppServer CREATE_FAILED: The requested configuration is currently not supported. Please check the documentation for supported configurations. Launching EC2 instance failed.
      InstanceType: "{{Arguments.InstanceType}}"
      AutoScaling:
        Minimum: 2
        Maximum: 20
        MetricType: CPU
        ScaleUpThreshold: 70
        ScaleDownThreshold: 40
      SecurityGroups:
        - app-{{Arguments.ApplicationId}}
      IamRoles:
        - app-{{Arguments.ApplicationId}}
      ElasticLoadBalancer: AppLoadBalancer
      AssociatePublicIpAddress: false # change for standalone deployment in default VPC
      TaupageConfig:
        application_id: "{{Arguments.ApplicationId}}"
        application_version: "{{Arguments.version}}"
        appdynamics_application: "My Cool Team"
        runtime: Docker
        source: "docker.io/myusr/pacts:{{Arguments.ImgTag}}"
        health_check_path: /diagnostic/status/heartbeat
        health_check_timeout_seconds: 90
        health_check_port: 443
        root: true
        # etcd_discovery_domain: "etcd.{{AccountInfo.TeamID}}"
        scalyr_account_key: "{{Arguments.ScalyrKey}}"
        # We use {{Arguments.AWSMintRegion}} instead of {{AccountInfo.Region}} because the mint bucket can by on any region
        mint_bucket: "myorg-stups-mint-{{AccountInfo.AccountID}}-{{Arguments.AWSMintRegion}}"
        ports:
          443: 443
        environment:
          # No need to set TOKENINFO_URL here since it should be automatically
          # set by taupage left this here for reference only
          # TOKENINFO_URL: "https://info.service.example.com/oauth2/tokeninfo"
          TOKENINFO_PARAMS: "?access_token="
          OAUTH2_ACCESS_TOKEN_URL: "https://token.service.example.com/oauth2/access_token"
          OAUTH2_ACCESS_TOKEN_PARAMS: "?realm=/services"
          # Enforce https on production/staging
          SKIP_HTTPS_ENFORCER: false
          BIND_TO: 0.0.0.0
          PACT_BROKER_PORT: 443
          RACK_THREADS_COUNT: 20
          STAGE: "{{Arguments.Stage}}"
          # Using AccountInfo is quite convenient
          ACCOUNTINFO_DOMAIN: "{{AccountInfo.Domain}}"
          ACCOUNTINFO_TEAMID: "{{AccountInfo.TeamID}}"
          ACCOUNTINFO_REGION: "{{AccountInfo.Region}}"
          ACCOUNTINFO_ACCOUNTID: "{{AccountInfo.AccountID}}"
          ACCOUNTINFO_ACCOUNTALIAS: "{{AccountInfo.AccountAlias}}"
          ACCOUNTINFO_VPCID: "{{AccountInfo.VpcID}}"
          # Nesting env vars like this produces something like this:
          # ACCINFO={'VPCID': 'vpc-11111111', 'ACCOUNTALIAS': 'myorg-myteam', 'ACCOUNTID': '111111111111', 'TEAMID': 'team', 'DOMAIN': 'team.myorg.net', 'REGION': 'eu-west-1'}
          ACCINFO:
            DOMAIN: "{{AccountInfo.Domain}}"
            TEAMID: "{{AccountInfo.TeamID}}"
            REGION: "{{AccountInfo.Region}}"
            ACCOUNTID: "{{AccountInfo.AccountID}}"
            ACCOUNTALIAS: "{{AccountInfo.AccountAlias}}"
            VPCID: "{{AccountInfo.VpcID}}"
          # live aka production
          LIVE_PACT_BROKER_DATABASE_NAME: "live_pacts"
          LIVE_PACT_BROKER_DATABASE_HOST: "aws:kms:SECRET!!!"
          LIVE_PACT_BROKER_DATABASE_USERNAME: "aws:kms:SECRET!!!"
          LIVE_PACT_BROKER_DATABASE_PASSWORD: "aws:kms:SECRET!!!"
          # test (staging)
          STAGING_PACT_BROKER_DATABASE_NAME: "staging_pact"
          STAGING_PACT_BROKER_DATABASE_HOST: "aws:kms:SECRET!!!"
          STAGING_PACT_BROKER_DATABASE_USERNAME: "aws:kms:SECRET!!!"
          STAGING_PACT_BROKER_DATABASE_PASSWORD: "aws:kms:SECRET!!!"
        #configure logrotate for application.log
        application_logrotate_size: 256M
        application_logrotate_interval: weekly
        application_logrotate_rotate: 4
        hostname: "{{Arguments.ApplicationId}}"
        # e.g. {{AccountInfo.Domain}} = myteam.example.org
        domain: "{{AccountInfo.Domain}}"
        # defaults
        privileged: false
        docker_daemon_access: false
        read_only: false
        mount_var_log: false
        mount_certs: false
        keep_instance_users: false
        enhanced_cloudwatch_metrics: false

  # creates an ELB entry and Route53 domains to this ELB
  - AppLoadBalancer:
      Type: Senza::WeightedDnsElasticLoadBalancer
      HTTPPort: 443
      HealthCheckPath: /diagnostic/status/heartbeat
      SecurityGroups:
        - app-{{Arguments.ApplicationId}}-lb
      Scheme: internet-facing
      # MainDomain: pacts-{{Arguments.Stage}}.{{AccountInfo.TeamID}}
      # VersionDomain: pacts-{{Arguments.Stage}}-{{SenzaInfo.StackVersion}}.{{AccountInfo.TeamID}}
      # aws iam list-server-certificates | jq -r '.ServerCertificateMetadataList[0].ServerCertificateName'
      # SSLCertificateId: myteam-ssl-cert-name
